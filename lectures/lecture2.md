#Права доступа

У каждого пользователя есть уникальный числовой идентификатор `uid`, который определяет его права в системе.
Может быть несколько пользователей с одним `uid`, но зачем.
У root'a всегда `uid=0`, у "обычных" пользователей они начинаются обычно с 1000.
Также можно разделять пользователей на группы, идентификатор группы называется `gid`.

В структуре `inode`, рассмотренной ранее, хранится `uid` пользователя - владельца этого файла. И 12 бит, которые называются `mode` и собственно являются правами доступа.
Они разделены на 4 октета. 
Первые три бита рассмотрим позже, оставшиеся 9 отвечают (от старших к младшим) за права доступа владельца файла, его группы и всех остальных.
Первый (старший) бит октета означает наличие или отсутствие права на чтение (`r - read`) , второй - на запись (`w - write`) , тертий - на исполнение (`x - execute`).
Пример: `rwxr-xr-x`. У владельца файла есть полный доступ, у его группы и всех остальных - только на чтение и исполнение.
Довольно часто используют запись числами, тогда верхний пример будет выглядеть как `755`.

С директориями чуть сложнее. Как мы знаем, директория - это таблица (или map) из названия в соответствующий `inode`. 
Право `r` дает возможность смотреть левую колонку таблицы (с именами), право `x` дает просмотр правой (с `inode`), право `w` дает возможность изменять содержимое обоих колонок.
То есть, если на папку права `r--`, можно посмотреть список файлов в ней, но к ним нельзя никак перейти (забавный факт №42).

Тут у нас возникает проблема. Представим директорию `/tmp`, в которой хранятся временные файлы всех пользователей. 
Допустим, пользователи `petya` и `vasya` хранят там свои картиночки. Если им обоим дать право `w`, они смогут удалить файлы друг друга, что не есть хорошо. Если им не давать этого права, они не смогут не то что удалить за собой файлы, они не смогут их даже создать.
Тут на помощь приходит первый октет в `mode`. Его последний бит называется sticky bit. Раньше от отвечал за что-то вроде "запрет выгружения исполняемого файла из памяти в swap", но теперь это используется по другому:
Если у директории установлен sticky bit, удалять файлы из неё может только владелец файла. Собственно, так решается проблема - устанавливаем у `tmp` sticky bit, даём Пете с Васей права `w`, они могут создавать там любые временные файлы, но удалять они смогут только то, что создали.
Такие типичные права доступа на общую папку выглядят как `1777`

Что мы с этим можем сделать? Есть команда `chmod`, которая изменяет права доступа (их может менять владелец файла) и `chown`, которая изменяет владельца файла (выполнять могут привелигированные пользователи, т.е. root)

#Процессы и их иерархия

У любого процесса есть `pid` - его уникальный id, и `ppid` - id его родителя. Также процесс хранит `uid` пользователя, который его запустил, и с правами которого он выполняется.

Процессы представлены в виде дерева, где корнем является `init`, который запускает все остальные процессы. 

##Zombie

Когда мы запускаем дочерний процесс, мы _скорее всего_ хотим знать, что с ним произошло, как минимум, код возврата.
Если наш "сын" завершилмся, то система не удаляет о нем информацию полностью, а хранит где-то некоторую инфу о нём (retcode, статистика использования ресурсов, и.т.д.)
Такие завершившиеся, но не удаленные процессы и называются **зомби**. Правила гласят, что родитель должен сам закапывать своих зомби. 
Например, если родитель создал процесс с помощью `fork`, то затем он должен вызвать `wait`, чтобы "забрать" информацию о сыне и удалить его из системы.
```c
wait(*retcode) //Ждёт любого сына
wait(pid, *retcode, *stat) //Ждёт процесс с заданным pid
```
На этом основано действие **fork-бомбы**. Если процесс-родитель не закапывает своих зомби, а только порождает новых, рано или поздно в системе кончатся дескрипторы для процессов, и вам будет очень-очень грустно.

Последнее замечание: если мы удаляем процесс, у которого ещё остались сыновья, то они переподвешиваются напрямую к `init`'у и считаются "осиротевшими". `init` их обычно должен убивать, но есть баганные реализации. Упс.

##Немного о sudo

> Процессы представлены в виде дерева, где корнем является `init`, который запускает все остальные процессы.

Где-то там есть и наш `bash`, в который мы залогинились, например, за Петю с `uid=1000`.
Теперь мы хотим сделать что-то, что требует повышенных привелегий, например, установить программу. Разлогиниваться и входить за root'a - долго и небезопасно.
Прошаренные линуксоиды, конечно, знают ответ: `sudo apt-get install`. 

`sudo` делает так, что процесс, который он вызывает (`apt` в нашем случае) выполняется с администраторскими правами - как будто его `uid` равен 0.
Как это происходит? Вспоминаем два последние бита `mode`, которые мы до сих пор не рассмотрели. Они называются `setuid` и `setgid`. Если они установлены в 1, то процесс запускается с правами, не текущего пользователя, а **владельца (группы владельца, если gid)** файла.
`sudo` лежит в `/usr/bin` и его владельцем является root. Он получает соответствующие права, проверяет пароль, и если Вася действительно обладает необходимыми правами, то запускает `apt`.
> Все программы, которые хотят проверять пароли (`/etc/shadow`, в котором хранятся хэши паролей, принадлежит root'у), или делать что-то ещё привелигированное, должны заранее обладать `setuid`, чтобы иметь возможность это проверять.
Проверка прав пользователя, который их запустил, лежит также на их совести. 

*NB: помимо бита `setuid`, есть функция `setuid`, однако, чем нужно обладать, чтобы её вызвать, так нормально и не объяснили. Сказано "читайте `man 7 capabilities` "*

*NB2:
у процесса нет `uid`, а есть целых три:*

    ruid = real uid //uid пользователя, который его запустил
    euid = effective uid //uid пользователя, по которому проверяются права
    suid = ... пользователь, который был до смены 
    
