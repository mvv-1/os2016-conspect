# State
Было бы классно, если бы никто снаружи не мог потрогать регистры внутри нашего миленького процесса.
Собственно, никто потрогать их и не может. И это хорошо. Но как это устроено?

Как-то так:
```
(args, p) = pop(processes)
restore_context(p)
p(args)
```
Некоторые интересные структурки для лучшего понимания
```c
struct regs_t {
	eax;
	ebx;
	...
};
```
```c
struct procinfo {
	pwd_process working_directory; // текущая директория
	regs_t regs;                   // регистры
	uid_t uid;                     // ид пользователя
	mmu_t mmu;                     // WTF
};
```
С памятью так не получится, ибо она здоровенная.
Чтобы решить проблему с общей памятью придумали виртуальную память.

Обычно данные в памяти лежат рядом подряд. Можно их побить на длянные сектора.
Так получилось, что они по 4 кБ.

Вообще говоря процесс не лезет по адресам напрямую в память;
процесс обращается по адресу в виртуальной памяти и получает значение из физической.
Не
```c
node *n = load(ptr);
```
а
```c
node *n = load(virt_to_phys(ptr));
```
Адресное пространство - множество адресуемой памяти у процесса.
```
|P| = 2<sup>64</sup>   // 32 - для 32 биток, то, что мы можем адресовать
|V| <lte> 4 * 2<sup>3+10</sup> * |P| // Размер оперативки
```
Впрочем, |V| нам может и не хватить. Для этого придумали swap.

# swap
Для того, чтобы лазать в память, в процессоре есть MMU - memory managment unit.
`palloc(/* unparcable иероглифы*/` находит n _последовательных_ страниц в виртуальной памяти и _как-то_ мапит их в физическую.
